#include "Loader.h"
#include "Intel.h"
#include "generator.h"

void VAR_WORD_(const char *name, ushort number) {
  LAB_(name);
  DB_(((uchar *)&number)[0]);
  DB_(((uchar *)&number)[1]);
}
void VAR_BYTE_(const char *name, uchar number) {
  LAB_(name);
  DB_(number);
}

void VAR_WORD_GLOBAL(const char *name, ushort number) {
  FUN_(name);
  DB_(((uchar *)&number)[0]);
  DB_(((uchar *)&number)[1]);
}
void VAR_BYTE_GLOBAL(const char *name, uchar number) {
  FUN_(name);
  DB_(number);
}


void Tr_Stop() {
  LAB_("ZZZ");
  NOP_();
  jmp_byte("ZZZ");
}
void MyPrint(const char *text) {

  FUN_("MyPrint");
  NOP_();
  movw("DI", ADR_("lText"));
  call_("PRINT16");
  jmp_byte("NEX");
  LAB_("lText");
  STR_(text);
  LAB_("NEX");
  NOP_();
  FUN_("MyPrint");
}
void MyPrint32(const char *text) {

  FUN_("MyPrint32");
   
  NOP_();
   
  mov_EDI_(ADR_("lText"));
  //movw("DI", ADR_("lText")); нужно будет выяснить почему тут зависало 
    
  call_("PRINT32");
  jmp_byte("NEX");
  LAB_("lText");
  STR_(text);
  LAB_("NEX");
  NOP_();
  FUN_("MyPrint32");

}

void IncludeMyPrint() {

  // =============================================
  // подпрограмам вывода строки в консоль в 16 битном режиме
  // В DS:DI должен быть адрес строки
  SetPlatform(PL_I16); // Выбираем платформу
  FUN_("PRINT16"); // Обьявляем новую область
  movw("AX", 0xB800); // mov ax,B800  Видеопамять
  mov_ES_AX();     // mov es,ax    в ES

  // Вычислем координату по Y
  mov_AX_A_(ADR_("CURR_Y"));
  movb("DL", 160);
  mul_DL_();

  // Вычислем координату по X
  mov_DX_A_(ADR_("CURR_X"));
  shl_DL_1_();
  add_AX_DX_();   
  mov_SI_AX_();

  LAB_("Cikl");     
  mov_AL_A_DI();    // mov al,[di]
  test_AL_AL_();    // test al,al
  jz_byte("EX");    // jz EX
  mov_A_ES_SI_AL(); // mov [ES:DI],AL Выводим сивмол на экран
  inc_SI_();        // inc Si
  movb("AL", 0x0F);
  mov_A_ES_SI_AL(); // mov [ES:SI],AL Выводим атрибуты сивмол на экран
  inc_SI_();        // inc Si
  inc_DI_();        // inc di
  jmp_byte("Cikl"); // jmp cikl       
  LAB_("EX");

  mov_DX_A_(ADR_("CURR_Y")); // Переход на след строку
  inc_DX_();
  mov_A_DX_(ADR_("CURR_Y"));
  movw("DX", 0);
  mov_A_DX_(ADR_("CURR_X"));
  ret_();
         
  //-------------------------------------------------------------------
  SetPlatform(PL_I32); // Выбираем платформу
  FUN_("PRINT32"); // Обьявляем новую область
  
  mov_EAX_(0);// ОБнуляю EAX                                    
  mov_EDX_(0);// ОБнуляю EDX                                      
  // Вычислем координату по Y
  mov_AX_A_DD(ADR_("CURR_Y"));// Читаю в AX координату по Y
  mov_DL_(160);//
  mul_DL_();//Умножаю координату по Y на длину строки в байтх 
  // Вычислем координату по X
  mov_DX_A_DD(ADR_("CURR_X"));// Загружаю коо по Х
  shl_DL_1_();// Умножаю на 2 
  add_AX_DX_(); // ПРиьавляю к координате  вычселеной по Y
  mov_EDX_(0xB8000);// ЗАгржаю адрес видео памяти 
  add_EAX_EDX_(); // ПРибавляю его к  
  mov_ESI_EAX_();

  LAB_("Cikl");
  mov_AL_A_DI();    // mov al,[di]
  test_AL_AL_();    // test al,al
  jz_byte("EX");    // jz EX
  mov_A_ESI_AL_(); // mov [ES:DI],AL Выводим сивмол на экран
  inc_ESI_();        // inc Si
  mov_AL_(0x0F);
  mov_A_ESI_AL_();   // mov [ESI],AL Выводим атрибуты сивмол на экран
  inc_ESI_();        // inc Si
  inc_DI_();        // inc di
  jmp_byte("Cikl"); // jmp cikl       
  LAB_("EX");
   NOP_();Tr_Stop()    ;
  mov_DX_A_DD(ADR_("CURR_Y")); // Переход на след строку
  inc_DX_();
  mov_A_DD_DX_(ADR_("CURR_Y"));         
  mov_DX_(0);       
  mov_A_DD_DX_(ADR_("CURR_X"));

  ret_();


  VAR_WORD_GLOBAL("CURR_X", 0);
  VAR_WORD_GLOBAL("CURR_Y", 0);
}
     
// Таблица GDT     
void  gdt_00(){
;// НУЛЕВОЙ ДИСКРИПТОР  -; // Его использовать в процессоре нельзя
dw_(0)   ; // младшее слово предела
dw_(0)   ; // младшее слово предела
db_(0)   ; // младшее слово адреса
db_(0)   ; // младшее слово адреса
db_(0)   ; // младшее слово адреса
db_(0)   ; // младшее слово адреса
;// ---------------------;
}
void  gdt_01(){
;// ДИСКРИПТОР КОДА -----; // CS
dw_(0xFFFF)     ;//;// младшее слово предела  размер сегмента минус один элемент
dw_(0x00)       ;//;// младшее слово адреса
db_(0x00)       ;//;// 3-й (из четырёх) байт адреса
db_(0b10011010) ;//;{  Свойства сегмента 10011010 
//;  1 = 1 Бит P (Present) - Присутствие сегмента в памяти. Если этот бит
//;        установлен, то сегмент есть в памяти, если сброшен, то его нет.
//;  2 = 0 Поле DPL 1 Бит  - Уровень привилегий, который имеет объект
//;  3 = 0 Поле DPL 2 Бит  - Уровень привилегий, который имеет объект
//;  4 = 1 Поле Тип Сегмента 1101 - Сегмент кода для выполнения/чтения
//;  5 = 1 Поле Тип Сегмента 1001 - Сегмент Данных
//;  6 = 0 Поле Тип Сегмента
//;  7 = 1 Поле Тип Сегмента
//;  8 = 0 использовался ли за последнее время этот сегмент или нет при первом
//;        же обращение в 1 устанавливаеться
//;//}
db_(0b11001111) ;//;b ;{  Свойства сегмента
//; 1 = 1 если 1 то размер указываеться в 4кб страницах иначе просто в байтах
//; 2 = 1 если 1 то 32 битный код в сегменте иначе 16 битный
//; 3 = 0 Зарезервированный бит. Intel не рекомендует использовать этот бит
//; 4 = 0 Бит пользователя. Этот бит процессор не использует и позволяет программе
//;       использовать его в своих целях.
//; 5 старшая часть предела
//; 6 старшая часть предела
//; 7 старшая часть предела
//; 8 старшая часть предела
//;}
db_(0x00)       ;// 4-й байт адреса
//;// ------------------------------------------------------------------;
}
void  gdt_02(){    
//;// ДИСКРИПТОР ДАННЫХ ------------------------------------------------; // DS
dw_(0xFFFF)    ;// младшее слово предела
dw_(0x00)      ;// младшее слово адреса
db_(0x00)      ;// 3-й (из четырёх) байт адреса
db_(0b10010010);//{ Свойства сегмента
//;  1 = 1 Бит P (Present) - Присутствие сегмента в памяти. Если этот бит
//;      установлен, то сегмент есть в памяти, если сброшен, то его нет.
//;  2 = 0 Поле DPL 1 Бит  - Уровень привилегий, который имеет объект
//;  3 = 0 Поле DPL 2 Бит  - Уровень привилегий, который имеет объект
//;  4 = 1 Поле Тип Сегмента 1101 - Сегмент кода для выполнения/чтения
//;  5 = 1 Поле Тип Сегмента 1001 - Сегмент Данных
//;  6 = 0 Поле Тип Сегмента
//;  7 = 1 Поле Тип Сегмента
//;  8 = 0 использовался ли за последнее время этот сегмент или нет при первом
//;        же обращение в 1 устанавливаеться
//;//}
db_(0b11001111); //;{ Свойства сегмента
//; 1 = 1 если 1 то размер указываеться в 4кб страницах иначе просто в байтах
//; 2 = 1 если 1 то 32 битный код в сегменте иначе 16 битный
//; 3 = 0 Зарезервированный бит. Intel не рекомендует использовать этот бит
//; 4 = 0 Бит пользователя. Этот бит процессор не использует и позволяет программе
//;       использовать его в своих целях.
//; 5 старшая часть предела
//; 6 старшая часть предела
//; 7 старшая часть предела
//; 8 старшая часть предела   
db_(0x00)       ;// 4-й байт адреса
;// ---------------------;
}
void  gdt(){

FUN_("GDT_START");
gdt_00();// НУЛЕВОЙ ДИСКРИПТОР
gdt_01();// Дексриптор кода 
gdt_02();// Дексриптор Данных  

int  Siz_Gdt=ADR_("GDT")-ADR_("GDT_START");

FUN_("GDT");
dw_(Siz_Gdt);// Рземер таблицы
dd_(ADR_("GDT_START"));// Адрес таблицы
FUN_("GDT_END");

//DB      $09,$08         ; // Размер таблицы
//DB      $09,$0A,$0B,$0C ; // Адрес таблицы

} 
// Таблица IDT    
void  idt(){ 
// Таблица IDT     

        LAB_("IDT_START");   
        //; //Interrupt Descriptor Table
        dd_(0);//; // 0  Division by zero
        dd_(0);//; // 1  Debugger
        dd_(0);//; // 2  NMI
        dd_(0);//; // 3  Breakpoint
        dd_(0);//; // 4  Overflow
        dd_(0);//; // 5  Bounds
        dd_(0);//; // 6  Invalid Opcode
        dd_(0);//; // 7  Coprocessor not available
        dd_(0);//; // 8  Double fault
        dd_(0);//; // 9  Coprocessor Segment Overrun (386 or earlier only)
        dd_(0);//; // 10 Invalid Task State Segment
        dd_(0);//; // 11 Segment not present
        dd_(0);//; // 12 Stack Fault
        dd_(0);//; // 13 General protection fault
        dd_(0);//; // 14 Page fault
        dd_(0);//; // 15 reserved
        dd_(0);//; // 16 Math Fault
        dd_(0);//; // 17 Alignment Check
        dd_(0);//; // 18 Machine Check
        dd_(0);//; // 19 SIMD Floating-Point Exception
        dd_(0);//; // 20 Virtualization Exception
        dd_(0);//; // 21 Control Protection Exception
        dd_(0);//; // 22
        dd_(0);//; // 23
        dd_(0);//; // 24
        dd_(0);//; // 25
        dd_(0);//; // 26
        dd_(0);//; // 27
        dd_(0);//; // 28
        dd_(0);//; // 29
        dd_(0);//; // 30
        dd_(0);//; // 31
        dd_(0);//; // IRQ 0 - системный таймер
        dd_(0);//; // IRQ 1 - клавиатура
        dd_(0);//; // IRQ 2 - Дополнительный контроллер прерываний
        dd_(0);//; // IRQ 3 - Порты Com 1 и 3
        dd_(0);//; // IRQ 4 - Порты Com 2 и 4
        dd_(0);//; // IRQ 5 - Свободно
        dd_(0);//; // IRQ 6 - Контроллер гибких дисков (FDD)
        dd_(0);//; // IRQ 7 - Параллельный порт LPT
        dd_(0);//; // IRQ 8 - Часы реального времени CMOS
        dd_(0);//; // IRQ 9 - Совмещено с IRQ 2
        dd_(0);//; // IRQ 10- Свободно
        dd_(0);//; // IRQ 11- Свободно
        dd_(0);//; // IRQ 12- Порт мыши PS/2
        dd_(0);//; // IRQ 13- Сопроцессор (в настоящее время не используется)
        dd_(0);//; // IRQ 14- Первый контроллер IDE
        dd_(0);//; // IRQ 15- Второй контроллер IDE
        //--------------------------------------------------------------
        dw_(0);// Размер таблицы прерываний -1 байт
        dd_(0);// Адрес таблицы прерываний
        LAB_("IDT_END");
}                    


void Loader() {

  SetPlatform(PL_I16); // Выбираем платформу
  ORG_(0x7C00); // Устанавливаем адрес работы программы
  FUN_("");     // Устанавливаем глобальную область видимости для меток
  // Устанавливаем сегментные регистры ===========
  xor_AX_AX(); // Обнуляем содержимое регистра AX
  mov_SS_AX(); // Устанавлиавем Сегмент стека 0
  mov_DS_AX(); // Устанавлиавем Сегмент данных 0
  mov_ES_AX(); // Устанавлиавем Сегмент Доп сег фиг зн зачем он нужен  0
  movw("SP", 0xFFFF);
  // =============================================

  // =============================================
  // Выбираем видео режим
  movb("AH", 0); // ПОдпрограмма установики  видео режима
  movb("AL", 3); // текст    80x25    16/8           CGA,EGA  b800  Comp,RGB,Enhanced
  int_(0x10); // Прерывание 10h

  // Выбираем страницу
  movb("AH", 5); // ПОдпрограмма выбора активной видео страницы
  movb("AL", 0); // Видео страница 0
  int_(0x10); // Прерывание 10h

  MyPrint(__DATE__" "__TIME__);
  MyPrint("Start Ok");

 // Прячем курсор
  movb("AH", 2);  // ПОдпрограмма установки курсора
  movb("BH", 0);  // Видео страница
  movb("DH", 25); // Номер строки установка в 25 делет невидимым курсор
  movb("DL", 0);  // Колонка
  int_(0x10);  // Прерывание 10h

  // =============================================
  MyPrint("Start load 18 sectors");

  // Загрузка оставшейся части программы с диска
  /* Источник http://www.codenet.ru/progr/dos/int_0012.php
  

  02H читать секторы
   вход: DL = номер диска (0=диск A...; 80H=тв.диск 0; 81H=тв.диск 1)
         DH = номер головки чтения/записи
         CH = номер дорожки (цилиндра)(0-n) =¬
         CL = номер сектора (1-n) ===========¦== См. замечание ниже.
         AL = число секторов (в сумме не больше чем один цилиндр)
         ES:BX => адрес буфера вызывающей программы
         0:0078 => таблица параметров дискеты (для гибких дисков)
         0:0104 => таблица параметров тв.диска (для твердых дисков)
  

  */

  movw("AX", 0);      // Не можем писать в ES напряимую тока через Рег
  mov_ES_AX();       // Адрес сегмента куда загружаем код
  movw("BX", 0x7E00); // Адрес внутри сегмента

  movb("DL", 0);  // Читаем с диска А
  movb("DH", 0);  // номер головки чтения/записи
  movb("CH", 0);  // Номер дорожки (цилиндра)(0-n)
  movb("CL", 2);  // Номер сектора
  movb("AL", 18); // Количество читаемых секторов
  movb("AH", 2);  // Номер подпрограммы прерывания 13h
  int_(0x13);  // Прерывание работа с диском

  MyPrint("End load 18 sectors");
  MyPrint("Init 32 bit mode");
  //Tr_Stop();
  //-----------;
  cli()        ; // Запрещаем прерывания 
  in_AL_(0x70) ; // Запрещаем NMI 
  or_AL_(0x80) ;
  out_AL_(0x70);
  //-----------;
  in_AL_(0x92) ;   
  or_AL_(2)    ; // Адресная линия A20   
  out_AL_(0x92);   
  //-----------;
  lgdt_(ADR_("GDT"));// Загрузка таблицы дискрипторов памяти  
  lidt_(ADR_("GDT"));// Загрузка таблицы дискрипторов прерываний
  //-----------;   
  mov_EAX_CR0();
  or_AL_(1)    ;
  mov_CR0_EAX();
  //-----------;
  jmp_32b(8,ADR_("32 Bit Start"));
  NOP_();
  IncludeMyPrint();
  FUN_("32 Bit Start");
  SetPlatform(PL_I32); // Выбираем платформу
  NOP_();
  // Загрузка селекторов 
  //;//---------------;
  mov_AX_(0x10);//mov ax, 10h       ;
  mov_DS_AX();//mov ds, ax
  mov_SS_AX();//mov ss, ax
  mov_ES_AX();//mov es, ax
  mov_SP_AX();//mov esp,2FFFFh;          
  mov_AX_(0x0);//mov ax, 0
  mov_FS_AX();//mov fs, ax
  mov_GS_AX();//mov gs, ax
  //;//---------------;  
                  
  MyPrint32("32 bit mode Ok.");
  Tr_Stop();
  

   //
  

  

  gdt();// Размещаме таблицу GDT

 
      
  Program[510] = 0x55;                    
  Program[511] = 0xaa;
}
